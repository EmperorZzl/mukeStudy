[{"/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/index.js":"1","/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/App.js":"2","/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/reportWebVitals.js":"3","/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/MyPromise/MyPromise.js":"4"},{"size":500,"mtime":1606807528049,"results":"5","hashOfConfig":"6"},{"size":1182,"mtime":1606819061370,"results":"7","hashOfConfig":"6"},{"size":362,"mtime":1606807528050,"results":"8","hashOfConfig":"6"},{"size":4351,"mtime":1606816168117,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"1pyqd5z",{"filePath":"13","messages":"14","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"12"},"/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/index.js",[],["20","21"],"/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/App.js",["22"],"/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/reportWebVitals.js",[],"/Users/devstrongzhao/dev/react/mukeStudy/my-react-app/src/MyPromise/MyPromise.js",["23","24","25"],"/**\n * 1.new Promise 时，需要传递一个executor执行器，执行器立刻执行\n * 2.executor 接收俩个参数，分别是resolve和reject\n * 3.promise 只能从pending到rejected，或者从pengding到fulfilled\n * 4.promise的状态一旦确认，就不会发生改变\n * 5.promise 都有then方法，then接收俩个参数，分别是promise成功的回调onfulfilled，和promise失败的回调onRejected\n * 6.如果低矮哦用then时，promise已经成功，则执行onFulfilled，并将promise的值作为参数传递进去。\n *    如果promise已经失败，那么执行 onRejected,并将promise失败的原因作为参数传递进去。\n *    如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确认后，在依次将对应的函数执行（发布订阅）\n * 7.then 的参数onFulfilled和onRejected可以缺省\n * 8.promise 可以then多次，promise的then方法返回一个promise\n * 9.如果then 返回的是一个结果，那么就会把这个结果作为参数，传递给下一个then的成功的回调（onFulfilled)\n * 10.如果then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调（onRejected)\n * 11.如果 then返回的是一个promise，那么需要等这个promise，那么回等这个promise执行完，promise如果成功就会走下一个then的成功，如果失败，就走下一个then的失败。\n * \n */\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(executor) {\n  let self = this;\n  self.status = PENDING;\n  self.onFulfilled = [];//成功的回调\n  self.onRejected = [];//失败的回调\n\n  function resolve(value) {\n    if (self.status === PENDING) {\n      self.status = FULFILLED;\n      self.value = value;\n      self.onFulfilled.forEach((fn) => fn());\n    }\n  }\n  function reject(reason) {\n    if (self.status === PENDING) {\n      self.status = REJECTED;\n      self.reason = reason;\n      self.onRejected.forEach((fn) => fn());\n    }\n  }\n  try {\n    executor(resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n  console.log('self', self);\n}\n\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n  onRejected = typeof onRejected === 'function' ? onRejected : value => value;\n  let self = this;\n  let promise2 = new MyPromise((resolve, reject) => {\n    if (self.status === FULFILLED) {\n      setTimeout(() => {\n        try {\n          let x = onFulfilled(self.value);\n          console.log('xxxx',x,self.value)\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      })\n    } else if (self.status === REJECTED) {\n      setTimeout(() => {\n        try {\n          let x = onRejected(self.reason);\n          resolvePromise(promise2, x, resolve, reject)\n        } catch (e) {\n          reject(e);\n        }\n      })\n    } else if (self.status === PENDING) {\n      self.onFulfilled.push(() => {\n        setTimeout(() => {\n          try {\n            let x = onFulfilled(self.value);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        })\n      });\n      self.onRejected.push(() => {\n        setTimeout(() => {\n          try {\n            let x = onRejected(self.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        })\n      })\n    }\n  })\n  return promise2;\n}\nfunction resolvePromise(promise2, x, resolve, reject) {\n  let self = this;\n  if (promise2 === x) {\n    reject(new TypeError('Chaining cycle'));\n  }\n  if (x && typeof x === 'object' || typeof x == 'function') {\n    let used;\n    try {\n      let then = x.then;\n      if (typeof then === 'function') {\n        then.call(x, (y) => {\n          if (used) return;\n          used = true;\n          resolvePromise(promise2, y, resolve, reject);\n        }, (r) => {\n          if (used) return;\n          used = true;\n          reject(r);\n        });\n      } else {\n        if (used) { return; }\n        used = true;\n        resolve(x);\n      }\n    } catch (e) {\n      if (used) return;\n      used = true;\n      reject(e);\n    }\n  } else {\n    resolve(x);\n  }\n}\n\nexport default MyPromise;\n",{"ruleId":"26","replacedBy":"27"},{"ruleId":"28","replacedBy":"29"},{"ruleId":"30","severity":1,"message":"31","line":3,"column":17,"nodeType":"32","messageId":"33","endLine":3,"endColumn":25},{"ruleId":"30","severity":1,"message":"34","line":99,"column":7,"nodeType":"32","messageId":"33","endLine":99,"endColumn":11},{"ruleId":"35","severity":1,"message":"36","line":103,"column":9,"nodeType":"37","messageId":"38","endLine":103,"endColumn":11},{"ruleId":"35","severity":1,"message":"36","line":103,"column":34,"nodeType":"37","messageId":"38","endLine":103,"endColumn":36},"no-native-reassign",["39"],"no-negated-in-lhs",["40"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'self' is assigned a value but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","no-global-assign","no-unsafe-negation"]